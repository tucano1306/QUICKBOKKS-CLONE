/**
 * Document AI Processing Service
 * 
 * Sistema inteligente de procesamiento de documentos contables
 * - OCR para extracción de texto
 * - IA para análisis y categorización
 * - Creación automática de asientos contables
 * - Actualización de base de datos en tiempo real
 * 
 * Florida/Miami USA - QuickBooks Clone
 */

import { prisma } from './prisma'

// Tipos
export interface DocumentAnalysis {
  documentType: 'INVOICE' | 'RECEIPT' | 'BANK_STATEMENT' | 'TAX_DOCUMENT' | 'CONTRACT' | 'EXPENSE_REPORT' | 'PAYROLL' | 'OTHER'
  confidence: number
  extractedData: ExtractedData
  suggestedAccount: {
    id: string
    code: string
    name: string
  } | null
  suggestedCategory: string
  journalEntry: JournalEntrySuggestion | null
  vendor: VendorMatch | null
  processingTime: number
}

export interface ExtractedData {
  amount: number | null
  date: string | null
  dueDate: string | null
  vendor: string | null
  invoiceNumber: string | null
  description: string | null
  taxAmount: number | null
  subtotal: number | null
  lineItems: LineItem[]
  taxId: string | null
  paymentMethod: string | null
}

export interface LineItem {
  description: string
  quantity: number
  unitPrice: number
  amount: number
}

export interface JournalEntrySuggestion {
  description: string
  lines: {
    accountCode: string
    accountName: string
    debit: number
    credit: number
  }[]
}

export interface VendorMatch {
  id: string
  name: string
  confidence: number
  isNew: boolean
}

interface ProcessingLog {
  stage: string
  status: 'SUCCESS' | 'ERROR' | 'WARNING'
  message: string
  details?: Record<string, unknown>
  duration: number
}

// ============================================
// OCR SERVICE - Extracción de texto
// ============================================

export async function extractTextFromDocument(
  buffer: Buffer,
  mimeType: string,
  filename: string
): Promise<{ text: string; confidence: number }> {
  const startTime = Date.now()
  
  // En producción, usar Tesseract.js o Google Vision API
  // Por ahora, simulamos basado en el contenido
  
  if (mimeType.includes('pdf')) {
    // Para PDFs, usar pdf-parse o similar
    // const pdfParse = require('pdf-parse')
    // const data = await pdfParse(buffer)
    // return { text: data.text, confidence: 95 }
  }
  
  if (mimeType.includes('image')) {
    // Para imágenes, usar Tesseract.js
    // const Tesseract = require('tesseract.js')
    // const { data } = await Tesseract.recognize(buffer, 'eng+spa')
    // return { text: data.text, confidence: data.confidence }
  }

  // Simulación inteligente basada en nombre de archivo
  const simulatedText = generateSimulatedOCRText(filename)
  
  return {
    text: simulatedText,
    confidence: 92
  }
}

function generateSimulatedOCRText(filename: string): string {
  const lower = filename.toLowerCase()
  const date = new Date().toISOString().split('T')[0]
  
  if (lower.includes('invoice') || lower.includes('factura')) {
    return `
INVOICE / FACTURA
Invoice Number: INV-${Date.now().toString().slice(-6)}
Date: ${date}
Due Date: ${new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0]}

From: ABC Supplies Inc.
Tax ID: 12-3456789
123 Business Ave, Miami, FL 33101

Bill To: Your Company
456 Main Street, Miami, FL 33102

Description                    Qty    Unit Price    Amount
Office Supplies               10      $25.00        $250.00
Printing Services              5      $50.00        $250.00
Software License               1     $199.00        $199.00

                              Subtotal:             $699.00
                              Sales Tax (7%):        $48.93
                              TOTAL:                $747.93

Payment Terms: Net 30
Payment Method: Bank Transfer
Bank: Chase Bank
Account: ****5678
    `
  }
  
  if (lower.includes('receipt') || lower.includes('recibo')) {
    return `
RECEIPT
Store: Office Depot #1234
123 Retail Blvd, Miami, FL 33101
Date: ${date}
Time: 14:32:45

Items Purchased:
Printer Paper (5 reams)         $45.99
Ink Cartridges                  $89.99
Stapler                         $12.99
Folders (pack of 50)            $24.99

Subtotal:                      $173.96
Sales Tax (7%):                 $12.18
TOTAL:                         $186.14

Payment: VISA ****4532
Authorization: 847291

Thank you for shopping with us!
    `
  }
  
  if (lower.includes('statement') || lower.includes('estado')) {
    return `
BANK STATEMENT
Bank of America
Account: ****5678
Period: ${new Date(Date.now() - 30*24*60*60*1000).toISOString().split('T')[0]} to ${date}

Beginning Balance:             $45,678.90

DEPOSITS & CREDITS
${date} Client Payment           $5,000.00
${date} Wire Transfer           $12,500.00
Total Deposits:                $17,500.00

WITHDRAWALS & DEBITS
${date} Rent Payment            $3,500.00
${date} Utilities                 $425.00
${date} Payroll                 $8,750.00
Total Withdrawals:             $12,675.00

Ending Balance:                $50,503.90
    `
  }
  
  if (lower.includes('1099') || lower.includes('w9') || lower.includes('tax')) {
    return `
FORM 1099-NEC
Tax Year: 2025

PAYER:
Your Company LLC
456 Main Street
Miami, FL 33102
TIN: 12-3456789

RECIPIENT:
Contractor Name
789 Work Ave
Miami, FL 33103
TIN: 98-7654321

Box 1 - Nonemployee Compensation: $15,000.00
Box 4 - Federal Income Tax Withheld: $0.00
    `
  }
  
  // Documento genérico
  return `
DOCUMENT
Date: ${date}
Reference: DOC-${Date.now().toString().slice(-6)}

This is a general business document.
Amount: $500.00
Category: General Expense

Please review and categorize accordingly.
  `
}

// ============================================
// AI ANALYSIS - Análisis inteligente
// ============================================

export async function analyzeDocumentWithAI(
  ocrText: string,
  companyId: string,
  filename: string
): Promise<DocumentAnalysis> {
  const startTime = Date.now()
  const logs: ProcessingLog[] = []
  
  // Paso 1: Clasificar tipo de documento
  const documentType = classifyDocument(ocrText, filename)
  logs.push({
    stage: 'CLASSIFICATION',
    status: 'SUCCESS',
    message: `Document classified as ${documentType}`,
    duration: Date.now() - startTime
  })
  
  // Paso 2: Extraer datos
  const extractedData = extractDataFromText(ocrText, documentType)
  logs.push({
    stage: 'EXTRACTION',
    status: 'SUCCESS',
    message: `Extracted ${Object.keys(extractedData).filter(k => extractedData[k as keyof ExtractedData] !== null).length} fields`,
    duration: Date.now() - startTime
  })
  
  // Paso 3: Buscar cuenta contable sugerida
  const suggestedAccount = await findSuggestedAccount(
    companyId,
    documentType,
    extractedData
  )
  
  // Paso 4: Buscar o crear vendor
  const vendor = await matchOrCreateVendor(companyId, extractedData.vendor)
  
  // Paso 5: Generar sugerencia de asiento contable
  const journalEntry = generateJournalEntrySuggestion(
    documentType,
    extractedData,
    suggestedAccount
  )
  
  // Paso 6: Determinar categoría
  const suggestedCategory = determineCategoryForFlorida(documentType, extractedData)
  
  return {
    documentType,
    confidence: calculateConfidence(ocrText, extractedData),
    extractedData,
    suggestedAccount,
    suggestedCategory,
    journalEntry,
    vendor,
    processingTime: Date.now() - startTime
  }
}

function classifyDocument(
  text: string,
  filename: string
): DocumentAnalysis['documentType'] {
  const lower = (text + ' ' + filename).toLowerCase()
  
  // Patrones para clasificación
  const patterns = {
    INVOICE: ['invoice', 'factura', 'bill to', 'due date', 'payment terms', 'inv-', 'invoice number'],
    RECEIPT: ['receipt', 'recibo', 'thank you for', 'change due', 'cashier', 'store #'],
    BANK_STATEMENT: ['statement', 'estado de cuenta', 'beginning balance', 'ending balance', 'deposits', 'withdrawals'],
    TAX_DOCUMENT: ['1099', 'w-9', 'w9', 'tax form', 'ein', 'tin', 'withholding', 'irs'],
    CONTRACT: ['contract', 'agreement', 'terms and conditions', 'hereby agree', 'contrato'],
    EXPENSE_REPORT: ['expense report', 'reimbursement', 'travel expense', 'mileage'],
    PAYROLL: ['payroll', 'paycheck', 'wages', 'salary', 'deductions', 'net pay']
  }
  
  let bestMatch: DocumentAnalysis['documentType'] = 'OTHER'
  let maxScore = 0
  
  for (const [type, keywords] of Object.entries(patterns)) {
    const score = keywords.filter(kw => lower.includes(kw)).length
    if (score > maxScore) {
      maxScore = score
      bestMatch = type as DocumentAnalysis['documentType']
    }
  }
  
  return bestMatch
}

function extractDataFromText(
  text: string,
  documentType: DocumentAnalysis['documentType']
): ExtractedData {
  const data: ExtractedData = {
    amount: null,
    date: null,
    dueDate: null,
    vendor: null,
    invoiceNumber: null,
    description: null,
    taxAmount: null,
    subtotal: null,
    lineItems: [],
    taxId: null,
    paymentMethod: null
  }
  
  // Extraer monto total
  const amountPatterns = [
    /total[:\s]*\$?([\d,]+\.?\d*)/i,
    /amount[:\s]*\$?([\d,]+\.?\d*)/i,
    /grand total[:\s]*\$?([\d,]+\.?\d*)/i,
    /balance[:\s]*\$?([\d,]+\.?\d*)/i
  ]
  
  for (const pattern of amountPatterns) {
    const match = text.match(pattern)
    if (match) {
      data.amount = parseFloat(match[1].replace(/,/g, ''))
      break
    }
  }
  
  // Extraer subtotal
  const subtotalMatch = text.match(/subtotal[:\s]*\$?([\d,]+\.?\d*)/i)
  if (subtotalMatch) {
    data.subtotal = parseFloat(subtotalMatch[1].replace(/,/g, ''))
  }
  
  // Extraer impuesto
  const taxPatterns = [
    /sales tax[:\s]*\(?\d*%?\)?[:\s]*\$?([\d,]+\.?\d*)/i,
    /tax[:\s]*\$?([\d,]+\.?\d*)/i,
    /iva[:\s]*\$?([\d,]+\.?\d*)/i
  ]
  
  for (const pattern of taxPatterns) {
    const match = text.match(pattern)
    if (match) {
      data.taxAmount = parseFloat(match[1].replace(/,/g, ''))
      break
    }
  }
  
  // Extraer fechas
  const datePatterns = [
    /date[:\s]*(\d{4}-\d{2}-\d{2})/i,
    /date[:\s]*(\d{2}\/\d{2}\/\d{4})/i,
    /fecha[:\s]*(\d{4}-\d{2}-\d{2})/i
  ]
  
  for (const pattern of datePatterns) {
    const match = text.match(pattern)
    if (match) {
      data.date = match[1]
      break
    }
  }
  
  // Extraer fecha de vencimiento
  const dueDateMatch = text.match(/due date[:\s]*(\d{4}-\d{2}-\d{2}|\d{2}\/\d{2}\/\d{4})/i)
  if (dueDateMatch) {
    data.dueDate = dueDateMatch[1]
  }
  
  // Extraer número de factura
  const invoicePatterns = [
    /invoice\s*(?:number|no|#)?[:\s]*([A-Z0-9-]+)/i,
    /inv[:\s#-]*([A-Z0-9-]+)/i,
    /factura[:\s#-]*([A-Z0-9-]+)/i
  ]
  
  for (const pattern of invoicePatterns) {
    const match = text.match(pattern)
    if (match) {
      data.invoiceNumber = match[1]
      break
    }
  }
  
  // Extraer vendor/proveedor
  const vendorPatterns = [
    /from[:\s]*([^\n]+)/i,
    /vendor[:\s]*([^\n]+)/i,
    /supplier[:\s]*([^\n]+)/i,
    /store[:\s]*([^\n]+)/i
  ]
  
  for (const pattern of vendorPatterns) {
    const match = text.match(pattern)
    if (match) {
      data.vendor = match[1].trim().replace(/\s+/g, ' ')
      break
    }
  }
  
  // Si no encontramos vendor, tomar primera línea significativa
  if (!data.vendor) {
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 3)
    for (const line of lines) {
      if (!line.toLowerCase().includes('invoice') && 
          !line.toLowerCase().includes('receipt') &&
          !line.toLowerCase().includes('date') &&
          line.length < 50) {
        data.vendor = line
        break
      }
    }
  }
  
  // Extraer Tax ID
  const taxIdMatch = text.match(/(?:tax id|tin|ein)[:\s]*(\d{2}-\d{7}|\d{9})/i)
  if (taxIdMatch) {
    data.taxId = taxIdMatch[1]
  }
  
  // Extraer método de pago
  const paymentPatterns = [
    /payment[:\s]*(visa|mastercard|amex|check|cash|transfer|wire)/i,
    /paid by[:\s]*(visa|mastercard|amex|check|cash|transfer|wire)/i
  ]
  
  for (const pattern of paymentPatterns) {
    const match = text.match(pattern)
    if (match) {
      data.paymentMethod = match[1].toUpperCase()
      break
    }
  }
  
  // Extraer líneas de items
  data.lineItems = extractLineItems(text)
  
  // Generar descripción
  if (!data.description) {
    data.description = generateDescription(documentType, data)
  }
  
  return data
}

function extractLineItems(text: string): LineItem[] {
  const items: LineItem[] = []
  
  // Patrón para líneas de items: Descripción  Qty  Price  Amount
  const linePattern = /([A-Za-z][\w\s]+?)\s+(\d+)\s+\$?([\d,.]+)\s+\$?([\d,.]+)/gm
  
  let match
  while ((match = linePattern.exec(text)) !== null) {
    const description = match[1].trim()
    const quantity = parseInt(match[2])
    const unitPrice = parseFloat(match[3].replace(/,/g, ''))
    const amount = parseFloat(match[4].replace(/,/g, ''))
    
    // Validar que no sea un encabezado
    if (!description.toLowerCase().includes('description') &&
        !description.toLowerCase().includes('qty') &&
        quantity > 0 && quantity < 1000) {
      items.push({ description, quantity, unitPrice, amount })
    }
  }
  
  return items
}

function generateDescription(
  documentType: DocumentAnalysis['documentType'],
  data: ExtractedData
): string {
  const parts: string[] = []
  
  if (data.vendor) parts.push(data.vendor)
  
  switch (documentType) {
    case 'INVOICE':
      parts.push('Invoice')
      if (data.invoiceNumber) parts.push(`#${data.invoiceNumber}`)
      break
    case 'RECEIPT':
      parts.push('Receipt')
      break
    case 'BANK_STATEMENT':
      parts.push('Bank Statement')
      break
    case 'TAX_DOCUMENT':
      parts.push('Tax Document')
      break
    default:
      parts.push('Document')
  }
  
  if (data.date) parts.push(`dated ${data.date}`)
  
  return parts.join(' - ')
}

async function findSuggestedAccount(
  companyId: string,
  documentType: DocumentAnalysis['documentType'],
  data: ExtractedData
): Promise<{ id: string; code: string; name: string } | null> {
  // Primero buscar reglas personalizadas de la empresa
  if (data.vendor) {
    const rule = await prisma.aiCategorizationRule.findFirst({
      where: {
        companyId,
        isActive: true,
        OR: [
          { vendorPattern: { contains: data.vendor, mode: 'insensitive' } },
          { descriptionPattern: { contains: data.vendor, mode: 'insensitive' } }
        ]
      },
      include: { account: true },
      orderBy: { priority: 'desc' }
    })
    
    if (rule) {
      // Incrementar contador de uso
      await prisma.aiCategorizationRule.update({
        where: { id: rule.id },
        data: { timesUsed: { increment: 1 } }
      })
      
      return {
        id: rule.account.id,
        code: rule.account.code,
        name: rule.account.name
      }
    }
  }
  
  // Mapeo por defecto según tipo de documento (Florida/USA)
  const accountMappings: Record<DocumentAnalysis['documentType'], { code: string; name: string }> = {
    'INVOICE': { code: '2000', name: 'Accounts Payable' },
    'RECEIPT': { code: '6100', name: 'Office Supplies Expense' },
    'BANK_STATEMENT': { code: '1000', name: 'Cash and Bank' },
    'TAX_DOCUMENT': { code: '2100', name: 'Taxes Payable' },
    'CONTRACT': { code: '1500', name: 'Prepaid Expenses' },
    'EXPENSE_REPORT': { code: '6200', name: 'Travel & Entertainment' },
    'PAYROLL': { code: '6000', name: 'Salaries and Wages' },
    'OTHER': { code: '6900', name: 'Other Expenses' }
  }
  
  const mapping = accountMappings[documentType]
  
  // Buscar cuenta en el plan de cuentas
  const account = await prisma.chartOfAccounts.findFirst({
    where: {
      OR: [
        { code: mapping.code },
        { name: { contains: mapping.name, mode: 'insensitive' } }
      ],
      isActive: true
    }
  })
  
  if (account) {
    return {
      id: account.id,
      code: account.code,
      name: account.name
    }
  }
  
  return null
}

async function matchOrCreateVendor(
  companyId: string,
  vendorName: string | null
): Promise<VendorMatch | null> {
  if (!vendorName) return null
  
  // Buscar vendor existente
  const existingVendor = await prisma.vendor.findFirst({
    where: {
      OR: [
        { name: { contains: vendorName, mode: 'insensitive' } },
        { name: { contains: vendorName.split(' ')[0], mode: 'insensitive' } }
      ]
    }
  })
  
  if (existingVendor) {
    return {
      id: existingVendor.id,
      name: existingVendor.name,
      confidence: 85,
      isNew: false
    }
  }
  
  // Sugerir crear nuevo vendor
  return {
    id: '',
    name: vendorName,
    confidence: 60,
    isNew: true
  }
}

function generateJournalEntrySuggestion(
  documentType: DocumentAnalysis['documentType'],
  data: ExtractedData,
  suggestedAccount: { id: string; code: string; name: string } | null
): JournalEntrySuggestion | null {
  if (!data.amount || !suggestedAccount) return null
  
  const amount = data.amount
  const taxAmount = data.taxAmount || 0
  const netAmount = amount - taxAmount
  
  switch (documentType) {
    case 'INVOICE':
      // Factura de proveedor - Partida doble
      return {
        description: `${data.vendor || 'Vendor'} - Invoice ${data.invoiceNumber || ''}`.trim(),
        lines: [
          {
            accountCode: '6100',
            accountName: 'Expenses',
            debit: netAmount,
            credit: 0
          },
          ...(taxAmount > 0 ? [{
            accountCode: '1400',
            accountName: 'Sales Tax Receivable',
            debit: taxAmount,
            credit: 0
          }] : []),
          {
            accountCode: '2000',
            accountName: 'Accounts Payable',
            debit: 0,
            credit: amount
          }
        ]
      }
      
    case 'RECEIPT':
      // Recibo de compra - Gasto directo
      return {
        description: `Purchase at ${data.vendor || 'Store'}`,
        lines: [
          {
            accountCode: suggestedAccount.code,
            accountName: suggestedAccount.name,
            debit: netAmount,
            credit: 0
          },
          ...(taxAmount > 0 ? [{
            accountCode: '1400',
            accountName: 'Sales Tax Paid',
            debit: taxAmount,
            credit: 0
          }] : []),
          {
            accountCode: '1000',
            accountName: 'Cash/Bank',
            debit: 0,
            credit: amount
          }
        ]
      }
      
    case 'BANK_STATEMENT':
      // Estado de cuenta - Solo referencia, no asiento automático
      return null
      
    default:
      return {
        description: data.description || 'Document',
        lines: [
          {
            accountCode: suggestedAccount.code,
            accountName: suggestedAccount.name,
            debit: amount,
            credit: 0
          },
          {
            accountCode: '2000',
            accountName: 'Accounts Payable',
            debit: 0,
            credit: amount
          }
        ]
      }
  }
}

function determineCategoryForFlorida(
  documentType: DocumentAnalysis['documentType'],
  data: ExtractedData
): string {
  // Categorías específicas para Florida/USA
  const vendor = (data.vendor || '').toLowerCase()
  const description = data.lineItems.map(i => i.description).join(' ').toLowerCase()
  
  // Detectar categorías específicas
  if (vendor.includes('office') || description.includes('paper') || description.includes('supplies')) {
    return 'Office Supplies & Expenses'
  }
  
  if (vendor.includes('electric') || vendor.includes('fpl') || vendor.includes('utility')) {
    return 'Utilities'
  }
  
  if (description.includes('software') || description.includes('license')) {
    return 'Software & Technology'
  }
  
  if (vendor.includes('insurance')) {
    return 'Insurance'
  }
  
  if (description.includes('travel') || description.includes('flight') || description.includes('hotel')) {
    return 'Travel & Entertainment'
  }
  
  // Categorías por tipo de documento
  const categoryMap: Record<DocumentAnalysis['documentType'], string> = {
    'INVOICE': 'Accounts Payable',
    'RECEIPT': 'Operating Expenses',
    'BANK_STATEMENT': 'Banking',
    'TAX_DOCUMENT': 'Tax Compliance',
    'CONTRACT': 'Legal & Professional',
    'EXPENSE_REPORT': 'Travel & Reimbursement',
    'PAYROLL': 'Payroll Expenses',
    'OTHER': 'General Expenses'
  }
  
  return categoryMap[documentType]
}

function calculateConfidence(text: string, data: ExtractedData): number {
  let score = 50 // Base score
  
  // Más datos extraídos = mayor confianza
  if (data.amount) score += 15
  if (data.date) score += 10
  if (data.vendor) score += 10
  if (data.invoiceNumber) score += 5
  if (data.lineItems.length > 0) score += 10
  
  // Texto largo = más información
  if (text.length > 500) score += 5
  if (text.length > 1000) score += 5
  
  return Math.min(score, 99)
}

// ============================================
// DATABASE OPERATIONS - Operaciones de BD
// ============================================

export async function createJournalEntryFromDocument(
  documentId: string,
  companyId: string,
  userId: string,
  suggestion: JournalEntrySuggestion
): Promise<string> {
  // Generar número de asiento
  const count = await prisma.journalEntry.count()
  const entryNumber = `JE-${(count + 1).toString().padStart(6, '0')}`
  
  // Crear asiento contable
  const journalEntry = await prisma.journalEntry.create({
    data: {
      entryNumber,
      date: new Date(),
      description: suggestion.description,
      status: 'DRAFT',
      createdBy: userId,
      companyId,
      lines: {
        create: suggestion.lines.map((line, index) => ({
          accountId: '', // Se debe buscar el ID real de la cuenta
          description: line.accountName,
          debit: line.debit,
          credit: line.credit,
          lineNumber: index + 1,
          companyId
        }))
      }
    }
  })
  
  // Actualizar documento con referencia al asiento
  await prisma.uploadedDocument.update({
    where: { id: documentId },
    data: { journalEntryId: journalEntry.id }
  })
  
  return journalEntry.id
}

export async function updateAccountBalances(
  journalEntryId: string
): Promise<void> {
  const entry = await prisma.journalEntry.findUnique({
    where: { id: journalEntryId },
    include: { lines: true }
  })
  
  if (!entry) return
  
  for (const line of entry.lines) {
    await prisma.chartOfAccounts.update({
      where: { id: line.accountId },
      data: {
        balance: {
          increment: line.debit - line.credit
        }
      }
    })
  }
}

// ============================================
// MAIN PROCESSING FUNCTION
// ============================================

export async function processDocument(
  documentId: string,
  buffer: Buffer,
  mimeType: string,
  filename: string,
  companyId: string,
  userId: string
): Promise<DocumentAnalysis> {
  const logs: ProcessingLog[] = []
  const startTime = Date.now()
  
  try {
    // Actualizar estado a procesando
    await prisma.uploadedDocument.update({
      where: { id: documentId },
      data: { status: 'PROCESSING' }
    })
    
    // Paso 1: OCR
    const ocrStart = Date.now()
    const { text: ocrText, confidence: ocrConfidence } = await extractTextFromDocument(
      buffer,
      mimeType,
      filename
    )
    
    await prisma.documentProcessingLog.create({
      data: {
        documentId,
        stage: 'OCR',
        status: 'SUCCESS',
        message: `Extracted ${ocrText.length} characters`,
        details: { confidence: ocrConfidence },
        duration: Date.now() - ocrStart
      }
    })
    
    // Paso 2: Análisis con IA
    const analysisStart = Date.now()
    const analysis = await analyzeDocumentWithAI(ocrText, companyId, filename)
    
    await prisma.documentProcessingLog.create({
      data: {
        documentId,
        stage: 'AI_ANALYSIS',
        status: 'SUCCESS',
        message: `Classified as ${analysis.documentType} with ${analysis.confidence}% confidence`,
        details: { 
          documentType: analysis.documentType,
          extractedFields: Object.keys(analysis.extractedData).filter(
            k => analysis.extractedData[k as keyof ExtractedData] !== null
          ).length
        },
        duration: Date.now() - analysisStart
      }
    })
    
    // Paso 3: Actualizar documento con análisis
    await prisma.uploadedDocument.update({
      where: { id: documentId },
      data: {
        status: 'ANALYZED',
        documentType: analysis.documentType,
        ocrText,
        ocrConfidence,
        aiAnalysis: analysis as unknown as Record<string, unknown>,
        extractedData: analysis.extractedData as unknown as Record<string, unknown>,
        suggestedAccountId: analysis.suggestedAccount?.id,
        suggestedCategory: analysis.suggestedCategory,
        aiConfidence: analysis.confidence,
        amount: analysis.extractedData.amount,
        documentDate: analysis.extractedData.date ? new Date(analysis.extractedData.date) : null,
        dueDate: analysis.extractedData.dueDate ? new Date(analysis.extractedData.dueDate) : null,
        invoiceNumber: analysis.extractedData.invoiceNumber,
        description: analysis.extractedData.description,
        vendorId: analysis.vendor?.isNew === false ? analysis.vendor.id : null,
        processingTime: Date.now() - startTime
      }
    })
    
    await prisma.documentProcessingLog.create({
      data: {
        documentId,
        stage: 'COMPLETE',
        status: 'SUCCESS',
        message: 'Document processed successfully',
        duration: Date.now() - startTime
      }
    })
    
    return analysis
    
  } catch (error) {
    // Registrar error
    await prisma.uploadedDocument.update({
      where: { id: documentId },
      data: {
        status: 'ERROR',
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      }
    })
    
    await prisma.documentProcessingLog.create({
      data: {
        documentId,
        stage: 'ERROR',
        status: 'ERROR',
        message: error instanceof Error ? error.message : 'Unknown error',
        duration: Date.now() - startTime
      }
    })
    
    throw error
  }
}
